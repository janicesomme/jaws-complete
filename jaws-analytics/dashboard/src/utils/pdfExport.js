import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'

/**
 * Generate and download PDF report from dashboard data
 * @param {Object} data - Dashboard data
 * @param {Object} data.buildData - Build stats (workflows, tables, tokens, completion)
 * @param {Object} data.summaries - Executive and technical summaries
 * @param {string} data.mermaidCode - Architecture diagram Mermaid code
 * @param {Array} data.workflows - Workflow breakdown data
 * @param {Object} data.timelineData - Build timeline data
 * @param {string} data.projectName - Project name for filename
 * @param {string} data.clientName - Client name
 * @param {string} viewMode - Current view mode ('client' or 'technical')
 */
export async function generatePDF(data, viewMode = 'client') {
  const {
    buildData,
    summaries,
    mermaidCode,
    workflows,
    timelineData,
    projectName = 'Project',
    clientName = 'Client'
  } = data

  // Initialize PDF (A4 size, portrait)
  const pdf = new jsPDF('p', 'mm', 'a4')
  const pageWidth = pdf.internal.pageSize.getWidth()
  const pageHeight = pdf.internal.pageSize.getHeight()
  const margin = 20

  // Color scheme
  const primaryColor = [79, 70, 229] // Blue-600
  const accentColor = [16, 185, 129] // Green-500
  const textColor = [31, 41, 55] // Gray-800
  const lightGray = [243, 244, 246] // Gray-100

  // Helper function to add page with header/footer
  const addPageWithHeader = () => {
    pdf.addPage()
    // Footer on each page
    pdf.setFontSize(8)
    pdf.setTextColor(107, 114, 128) // Gray-500
    const footerText = `Generated by JAWS Analytics | ${new Date().toLocaleDateString()}`
    const footerX = pageWidth - margin - pdf.getTextWidth(footerText)
    pdf.text(footerText, footerX, pageHeight - 10)
  }

  // ============================================================
  // COVER PAGE
  // ============================================================

  // Logo/Brand Mark (Gradient-style box with J)
  pdf.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.roundedRect(margin, 40, 30, 30, 3, 3, 'F')
  pdf.setFontSize(32)
  pdf.setTextColor(255, 255, 255)
  pdf.text('J', margin + 9, 62)

  // Title
  pdf.setFontSize(36)
  pdf.setTextColor(textColor[0], textColor[1], textColor[2])
  pdf.setFont('helvetica', 'bold')
  pdf.text('Analytics Report', margin, 100)

  // Project Name
  pdf.setFontSize(24)
  pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.text(projectName, margin, 115)

  // Client Name
  pdf.setFontSize(14)
  pdf.setTextColor(107, 114, 128) // Gray-500
  pdf.text(`Client: ${clientName}`, margin, 125)

  // Date
  const reportDate = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
  pdf.text(`Report Date: ${reportDate}`, margin, 133)

  // Subtitle
  pdf.setFontSize(12)
  pdf.setTextColor(textColor[0], textColor[1], textColor[2])
  pdf.setFont('helvetica', 'normal')
  const subtitle = viewMode === 'client'
    ? 'Professional Dashboard Export - Client View'
    : 'Technical Deep Dive - Complete Analysis'
  pdf.text(subtitle, margin, 145)

  // Brand line
  pdf.setFontSize(10)
  pdf.setTextColor(107, 114, 128)
  pdf.text('Powered by Janice\'s AI Automation Consulting', margin, pageHeight - 30)

  // ============================================================
  // PAGE 2: EXECUTIVE SUMMARY
  // ============================================================

  addPageWithHeader()
  let yPos = 30

  // Section Title
  pdf.setFontSize(18)
  pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.setFont('helvetica', 'bold')
  pdf.text('Executive Summary', margin, yPos)
  yPos += 12

  // Summary Content
  pdf.setFontSize(11)
  pdf.setTextColor(textColor[0], textColor[1], textColor[2])
  pdf.setFont('helvetica', 'normal')
  const summaryText = viewMode === 'client'
    ? summaries.executive_summary
    : summaries.technical_summary
  const splitSummary = pdf.splitTextToSize(summaryText, pageWidth - 2 * margin)
  pdf.text(splitSummary, margin, yPos)
  yPos += splitSummary.length * 6 + 10

  // Value Proposition (Client view only)
  if (viewMode === 'client' && summaries.value_proposition) {
    pdf.setFontSize(14)
    pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
    pdf.setFont('helvetica', 'bold')
    pdf.text('Value Delivered', margin, yPos)
    yPos += 10

    pdf.setFontSize(11)
    pdf.setTextColor(textColor[0], textColor[1], textColor[2])
    pdf.setFont('helvetica', 'normal')
    const splitValue = pdf.splitTextToSize(summaries.value_proposition, pageWidth - 2 * margin)
    pdf.text(splitValue, margin, yPos)
    yPos += splitValue.length * 6 + 10
  }

  // ============================================================
  // PAGE 3: KEY METRICS
  // ============================================================

  addPageWithHeader()
  yPos = 30

  pdf.setFontSize(18)
  pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.setFont('helvetica', 'bold')
  pdf.text('Key Metrics', margin, yPos)
  yPos += 15

  // Stats Cards in grid (2x2)
  const cardWidth = (pageWidth - 2 * margin - 10) / 2
  const cardHeight = 35
  const cardMargin = 5

  const stats = [
    {
      label: 'Workflows Created',
      value: buildData.workflows_created || 0,
      icon: 'âš™ï¸'
    },
    {
      label: 'Tables Created',
      value: buildData.tables_created || 0,
      icon: 'ðŸ—„ï¸'
    },
    {
      label: 'Est. Tokens per Run',
      value: (buildData.estimated_tokens_per_run || 0).toLocaleString(),
      icon: 'ðŸ”¢'
    },
    {
      label: 'Completion Rate',
      value: buildData.tasks_total > 0
        ? `${Math.round((buildData.tasks_completed / buildData.tasks_total) * 100)}%`
        : '0%',
      icon: 'âœ“'
    }
  ]

  stats.forEach((stat, index) => {
    const col = index % 2
    const row = Math.floor(index / 2)
    const x = margin + col * (cardWidth + cardMargin)
    const y = yPos + row * (cardHeight + cardMargin)

    // Card background
    pdf.setFillColor(lightGray[0], lightGray[1], lightGray[2])
    pdf.roundedRect(x, y, cardWidth, cardHeight, 2, 2, 'F')

    // Icon
    pdf.setFontSize(20)
    pdf.text(stat.icon, x + 5, y + 15)

    // Value
    pdf.setFontSize(24)
    pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
    pdf.setFont('helvetica', 'bold')
    pdf.text(String(stat.value), x + 5, y + 26)

    // Label
    pdf.setFontSize(10)
    pdf.setTextColor(107, 114, 128)
    pdf.setFont('helvetica', 'normal')
    pdf.text(stat.label, x + 5, y + 32)
  })

  yPos += (Math.ceil(stats.length / 2) * (cardHeight + cardMargin)) + 20

  // ============================================================
  // PAGE 4: COST PROJECTIONS
  // ============================================================

  if (buildData.estimated_tokens_per_run) {
    yPos += 15
    if (yPos > pageHeight - 60) {
      addPageWithHeader()
      yPos = 30
    }

    pdf.setFontSize(16)
    pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
    pdf.setFont('helvetica', 'bold')
    pdf.text('Cost Projections', margin, yPos)
    yPos += 12

    // Calculate costs
    const inputTokens = Math.round(buildData.estimated_tokens_per_run * 0.7) // Estimate 70% input
    const outputTokens = Math.round(buildData.estimated_tokens_per_run * 0.3) // 30% output
    const costPerRun = (inputTokens * 3 / 1000000) + (outputTokens * 15 / 1000000)
    const monthlyRuns = 100 // Assumption
    const monthlyCost = costPerRun * monthlyRuns

    pdf.setFontSize(11)
    pdf.setTextColor(textColor[0], textColor[1], textColor[2])
    pdf.setFont('helvetica', 'normal')

    const costDetails = [
      `Estimated tokens per run: ${buildData.estimated_tokens_per_run.toLocaleString()}`,
      `Input tokens (~70%): ${inputTokens.toLocaleString()}`,
      `Output tokens (~30%): ${outputTokens.toLocaleString()}`,
      `Cost per run: $${costPerRun.toFixed(4)}`,
      ``,
      `Monthly estimate (100 runs): $${monthlyCost.toFixed(2)}/month`,
      `Annual estimate: $${(monthlyCost * 12).toFixed(2)}/year`
    ]

    costDetails.forEach(line => {
      if (line) {
        pdf.text(line, margin + 5, yPos)
      }
      yPos += 6
    })
  }

  // ============================================================
  // PAGE 5: WORKFLOW BREAKDOWN
  // ============================================================

  addPageWithHeader()
  yPos = 30

  pdf.setFontSize(18)
  pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.setFont('helvetica', 'bold')
  pdf.text('Workflow Breakdown', margin, yPos)
  yPos += 12

  // Table header
  pdf.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.rect(margin, yPos, pageWidth - 2 * margin, 8, 'F')
  pdf.setFontSize(9)
  pdf.setTextColor(255, 255, 255)
  pdf.setFont('helvetica', 'bold')
  pdf.text('Workflow Name', margin + 2, yPos + 6)
  pdf.text('Type', margin + 65, yPos + 6)
  pdf.text('Nodes', margin + 95, yPos + 6)
  pdf.text('Tokens', margin + 115, yPos + 6)
  yPos += 10

  // Table rows
  workflows.slice(0, 10).forEach((workflow, index) => {
    if (yPos > pageHeight - 30) {
      addPageWithHeader()
      yPos = 30
    }

    pdf.setFillColor(index % 2 === 0 ? 255 : lightGray[0], index % 2 === 0 ? 255 : lightGray[1], index % 2 === 0 ? 255 : lightGray[2])
    pdf.rect(margin, yPos - 5, pageWidth - 2 * margin, 8, 'F')

    pdf.setFontSize(9)
    pdf.setTextColor(textColor[0], textColor[1], textColor[2])
    pdf.setFont('helvetica', 'normal')

    const workflowName = workflow.workflow_name.length > 25
      ? workflow.workflow_name.substring(0, 25) + '...'
      : workflow.workflow_name
    pdf.text(workflowName, margin + 2, yPos)
    pdf.text(workflow.workflow_type || '-', margin + 65, yPos)
    pdf.text(String(workflow.node_count || 0), margin + 95, yPos)
    pdf.text((workflow.estimated_tokens || 0).toLocaleString(), margin + 115, yPos)
    yPos += 8
  })

  if (workflows.length > 10) {
    pdf.setFontSize(9)
    pdf.setTextColor(107, 114, 128)
    pdf.text(`... and ${workflows.length - 10} more workflows`, margin + 2, yPos + 5)
  }

  // ============================================================
  // PAGE 6: ARCHITECTURE DIAGRAM (Capture from DOM)
  // ============================================================

  addPageWithHeader()
  yPos = 30

  pdf.setFontSize(18)
  pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  pdf.setFont('helvetica', 'bold')
  pdf.text('System Architecture', margin, yPos)
  yPos += 12

  // Note: Architecture diagram requires special handling
  // We'll add a placeholder for now and capture it later from DOM
  pdf.setFontSize(11)
  pdf.setTextColor(textColor[0], textColor[1], textColor[2])
  pdf.setFont('helvetica', 'normal')
  pdf.text('Architecture Diagram:', margin, yPos)
  yPos += 8

  if (summaries.architecture_description) {
    const splitArch = pdf.splitTextToSize(summaries.architecture_description, pageWidth - 2 * margin)
    pdf.text(splitArch, margin, yPos)
  }

  // ============================================================
  // FINAL PAGE: BUILD TIMELINE SUMMARY
  // ============================================================

  if (timelineData && timelineData.phases) {
    addPageWithHeader()
    yPos = 30

    pdf.setFontSize(18)
    pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
    pdf.setFont('helvetica', 'bold')
    pdf.text('Build Timeline', margin, yPos)
    yPos += 12

    pdf.setFontSize(11)
    pdf.setTextColor(textColor[0], textColor[1], textColor[2])
    pdf.setFont('helvetica', 'normal')

    const timelineStats = [
      `Total Iterations: ${timelineData.iterations_used} of ${timelineData.iterations_max}`,
      `Build Duration: ${Math.floor(timelineData.build_duration_minutes / 60)}h ${timelineData.build_duration_minutes % 60}m`,
      `Checkpoints Triggered: ${timelineData.checkpoints_triggered}`,
      `Phases: ${timelineData.phases.length}`
    ]

    timelineStats.forEach(stat => {
      pdf.text(stat, margin + 5, yPos)
      yPos += 7
    })

    yPos += 10

    // Phase summary
    pdf.setFontSize(14)
    pdf.setFont('helvetica', 'bold')
    pdf.text('Phase Summary', margin, yPos)
    yPos += 10

    timelineData.phases.forEach(phase => {
      if (yPos > pageHeight - 30) {
        addPageWithHeader()
        yPos = 30
      }

      pdf.setFontSize(11)
      pdf.setFont('helvetica', 'bold')
      pdf.setTextColor(phase.status === 'completed' ? accentColor[0] : primaryColor[0],
                        phase.status === 'completed' ? accentColor[1] : primaryColor[1],
                        phase.status === 'completed' ? accentColor[2] : primaryColor[2])
      const statusIcon = phase.status === 'completed' ? 'âœ“' : 'âŸ³'
      pdf.text(`${statusIcon} Phase ${phase.phase}: ${phase.name}`, margin + 5, yPos)
      yPos += 6

      pdf.setFontSize(9)
      pdf.setTextColor(textColor[0], textColor[1], textColor[2])
      pdf.setFont('helvetica', 'normal')
      pdf.text(`Iterations ${phase.iterations_start}-${phase.iterations_end} | Tasks: ${phase.tasks_completed}/${phase.tasks_total}`, margin + 8, yPos)
      yPos += 10
    })
  }

  // ============================================================
  // SAVE PDF
  // ============================================================

  const filename = `${projectName.toLowerCase().replace(/\s+/g, '-')}-analytics.pdf`
  pdf.save(filename)

  return filename
}

/**
 * Capture architecture diagram from DOM and add to PDF
 * @param {jsPDF} pdf - PDF document
 * @param {string} selector - DOM selector for diagram element
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} width - Max width
 * @param {number} height - Max height
 */
export async function addDiagramToPDF(pdf, selector, x, y, width, height) {
  try {
    const element = document.querySelector(selector)
    if (!element) return

    const canvas = await html2canvas(element, {
      scale: 2,
      backgroundColor: '#ffffff'
    })

    const imgData = canvas.toDataURL('image/png')

    // Calculate aspect ratio to fit within bounds
    const aspectRatio = canvas.width / canvas.height
    let imgWidth = width
    let imgHeight = width / aspectRatio

    if (imgHeight > height) {
      imgHeight = height
      imgWidth = height * aspectRatio
    }

    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight)
  } catch (error) {
    console.error('Error capturing diagram:', error)
  }
}
